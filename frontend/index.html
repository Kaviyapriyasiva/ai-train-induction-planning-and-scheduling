<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KMRL AI Operations Dashboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 0.95em;
        }

        .nav-tabs {
            display: flex;
            background: #f8f9fa;
            border-bottom: 2px solid #dee2e6;
        }

        .nav-tab {
            flex: 1;
            padding: 15px 20px;
            background: #f8f9fa;
            border: none;
            cursor: pointer;
            font-size: 1em;
            font-weight: 500;
            transition: all 0.3s;
            border-right: 1px solid #dee2e6;
        }

        .nav-tab:hover {
            background: #e9ecef;
        }

        .nav-tab.active {
            background: white;
            color: #667eea;
            border-bottom: 2px solid #667eea;
            margin-bottom: -2px;
        }

        .tab-content {
            display: none;
            padding: 30px;
            animation: fadeIn 0.3s;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
        }

        .control-group label {
            font-weight: 600;
            margin-bottom: 8px;
            color: #495057;
            font-size: 0.9em;
        }

        .control-group input,
        .control-group select {
            padding: 10px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        .control-group input:focus,
        .control-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 30px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-top: auto;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .card {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            padding: 20px;
            transition: box-shadow 0.3s;
        }

        .card:hover {
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        }

        .card h3 {
            color: #495057;
            margin-bottom: 15px;
            font-size: 1.1em;
        }

        .metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 10px;
        }

        .metric-label {
            font-weight: 600;
            color: #6c757d;
        }

        .metric-value {
            font-size: 1.5em;
            font-weight: 700;
            color: #667eea;
        }

        .station-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .station-item {
            padding: 12px;
            margin-bottom: 8px;
            background: #f8f9fa;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
            transition: background 0.3s;
        }

        .station-item:hover {
            background: #e9ecef;
        }

        .info-box {
            background: #e7f3ff;
            border-left: 4px solid #667eea;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }

        .warning-box {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }

        .success-box {
            background: #d4edda;
            border-left: 4px solid #28a745;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }

        .error-box {
            background: #f8d7da;
            border-left: 4px solid #dc3545;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }

        .chart-container {
            position: relative;
            height: 300px;
            margin: 20px 0;
        }

        .heatmap-container {
            overflow-x: auto;
            margin: 20px 0;
        }

        .heatmap {
            display: grid;
            gap: 2px;
            min-width: 800px;
        }

        .heatmap-row {
            display: grid;
            grid-template-columns: 150px repeat(24, 1fr);
            gap: 2px;
        }

        .heatmap-cell {
            padding: 8px;
            text-align: center;
            font-size: 0.8em;
            border-radius: 4px;
            font-weight: 600;
            transition: opacity 0.2s ease;
            cursor: pointer;
        }

        .heatmap-cell:hover {
            opacity: 0.7;
        }

        .heatmap-header {
            background: #495057;
            color: white;
            font-weight: 700;
        }

        .heatmap-label {
            background: #6c757d;
            color: white;
            display: flex;
            align-items: center;
            padding-left: 10px;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #667eea;
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üöÜ Kochi Metro ‚Äì AI Operations Control Dashboard</h1>
            <p>Weather-Aware Demand Forecasting & Intelligent Train Management</p>
        </div>

        <div class="nav-tabs">
            <button class="nav-tab active" onclick="switchTab(0)">üöÜ Operations Control</button>
            <button class="nav-tab" onclick="switchTab(1)">üìä Demand Analytics</button>
            <button class="nav-tab" onclick="switchTab(2)">üöÜ Train Planning</button>
            <button class="nav-tab" onclick="switchTab(3)">üîÆ Scenario Simulator</button>
        </div>

        <!-- TAB 1: Operations Control -->
        <div class="tab-content active">
            <div class="controls">
                <div class="control-group">
                    <label>Hour</label>
                    <input type="range" id="hour" min="0" max="23" value="9" oninput="updateHourDisplay(this.value)">
                    <span id="hourDisplay">9:00</span>
                </div>
                <div class="control-group">
                    <label>Day Type</label>
                    <select id="dayType">
                        <option value="weekday">Weekday</option>
                        <option value="weekend">Weekend</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Current Trains / Hour</label>
                    <input type="range" id="trainsPerHour" min="1" max="10" value="5" oninput="updateTrainsPerHourDisplay(this.value)">
                    <span id="trainsDisplay">5</span>
                </div>
                <div class="control-group">
                    <label>Direction</label>
                    <select id="direction">
                        <option value="0">Aluva ‚Üí Ernakulam</option>
                        <option value="1">Ernakulam ‚Üí Aluva</option>
                    </select>
                </div>
                <div class="control-group">
                    <button class="btn" onclick="runAI()">üîÆ Run AI</button>
                </div>
            </div>

            <div class="grid">
                <div class="card">
                    <h3>üó∫Ô∏è Metro Line Status</h3>
                    <div class="station-list" id="stationList"></div>
                </div>

                <div class="card">
                    <h3>ü§ñ AI Recommendation</h3>
                    <div id="aiRecommendation">
                        <div class="info-box">Run AI to generate recommendation</div>
                    </div>
                </div>

                <div class="card">
                    <h3>üìä KPIs</h3>
                    <div id="kpis">
                        <div class="metric">
                            <span class="metric-label">‚è± Waiting Time</span>
                            <span class="metric-value">-</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">üë• Load %</span>
                            <span class="metric-value">-</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">‚ö° Energy %</span>
                            <span class="metric-value">-</span>
                        </div>
                        <div class="metric">
                            <span class="metric-label">üôÇ Comfort %</span>
                            <span class="metric-value">-</span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="card">
                <h3>üìà Passenger Demand Trend</h3>
                <div class="chart-container">
                    <canvas id="demandChart"></canvas>
                </div>
            </div>
        </div>

        <!-- TAB 2: Demand Analytics -->
        <div class="tab-content">
            <div class="controls">
                <div class="control-group">
                    <label>üìÖ Select Date</label>
                    <input type="date" id="analyticsDate">
                </div>
                <div class="control-group">
                    <label>‚è± Time Range Start</label>
                    <input type="number" id="timeStart" min="0" max="23" value="6">
                </div>
                <div class="control-group">
                    <label>‚è± Time Range End</label>
                    <input type="number" id="timeEnd" min="0" max="23" value="22">
                </div>
                <div class="control-group">
                    <label>Day Type</label>
                    <select id="analyticsDayType">
                        <option value="weekday">Weekday</option>
                        <option value="weekend">Weekend</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Compare Previous Week</label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="comparePrev">
                        <span class="slider"></span>
                    </label>
                </div>
                <div class="control-group">
                    <button class="btn" onclick="runDemandAnalytics()">Run</button>
                </div>
                
            </div>

            <div class="card">
                <h3>üî• Station-wise Passenger Demand Heatmap</h3>
                <div class="heatmap-container" id="heatmapContainer"></div>
                <p style="color: #6c757d; font-size: 0.9em; margin-top: 10px;">Darker colors indicate higher passenger congestion</p>
            </div>

            <div class="card">
                <h3>üìà Historical vs AI-Predicted Demand</h3>
                <div class="chart-container">
                    <canvas id="historicalVsPredictedChart"></canvas>
                </div>
            </div>
        </div>

        <!-- TAB 3: Train Planning -->
        <div class="tab-content">
            <div class="grid">
                <div class="card">
                    <h3>‚öôÔ∏è Planning Inputs</h3>
                    <div class="control-group" style="margin-bottom: 15px;">
                        <label>Available Trains</label>
                        <input type="range" id="availableTrains" min="2" max="20" value="10" oninput="updateTrainsDisplay(this.value)">
                        <span id="availableTrainsDisplay">10</span>
                    </div>
                    <div class="control-group" style="margin-bottom: 15px;">
                        <label>Peak Hour Mode</label>
                        <label class="toggle-switch">
                            <input type="checkbox" id="peakMode" checked>
                            <span class="slider"></span>
                        </label>
                    </div>
                    <button class="btn" onclick="generatePlan()" style="width: 100%;">ü§ñ Generate AI Plan</button>
                </div>

                <div class="card" style="grid-column: span 2;">
                    
                    <div id="planningOutput">
                        <div class="info-box">Adjust inputs and click <strong>Generate AI Plan</strong> to view recommendations</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- TAB 4: Scenario Simulator -->
        <div class="tab-content">
            <div class="grid">
                <div class="card">
                    <h3>‚öôÔ∏è Scenario Inputs</h3>
                    <div class="control-group" style="margin-bottom: 15px;">
                        <label>üìÖ Select Scenario Date</label>
                        <input type="date" id="scenarioDate">
                    </div>
                    <div class="control-group" style="margin-bottom: 15px;">
                        <label>Passenger Demand Increase (%)</label>
                        <input type="range" id="demandIncrease" min="0" max="100" value="20" oninput="updateDemandDisplay(this.value)">
                        <span id="demandIncreaseDisplay">20%</span>
                    </div>
                    <div class="control-group" style="margin-bottom: 15px;">
                        <label>Trains Unavailable</label>
                        <input type="range" id="unavailableTrains" min="0" max="10" value="2" oninput="updateUnavailableDisplay(this.value)">
                        <span id="unavailableDisplay">2</span>
                    </div>
                    <div class="control-group" style="margin-bottom: 15px;">
                        <label>üå¶Ô∏è Special Events</label>
                        <div style="display: flex; gap: 15px; margin-top: 10px;">
                            <label><input type="checkbox" id="rain"> Rain</label>
                            <label><input type="checkbox" id="festival"> Festival</label>
                        </div>
                    </div>
                    <button class="btn" onclick="runSimulation()" style="width: 100%;">üîÅ Run Simulation</button>
                </div>

                <div class="card" style="grid-column: span 2;">
                    <h3>üìä Simulation Results</h3>
                    <div id="simulationResults">
                        <div class="info-box">Adjust scenario parameters and click <strong>Run Simulation</strong></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script>
    const MIN_TRAINS = 2;
    const MAX_TRAINS = 20;
    const API_BASE = "http://localhost:8001/api";
    const TRAIN_CAPACITY = 400; // Passengers per train

    // ========== WEATHER API ==========
    async function getWeatherData(city = "Kochi") {
        try {
            const res = await fetch(`https://api.weatherapi.com/v1/current.json?key=&q=${city}&aqi=no`);
            const d = await res.json();
            return {
                temp: d.current.temp_c,
                rain_mm: d.current.precip_mm,
                condition: d.current.condition.text
            };
        } catch (e) {
            return { temp: 28, rain_mm: 0, condition: "Clear" };
        }
    }

    // ========== DEMAND FORECASTING API ==========
    async function fetchDemandForecast(hour, isWeekend, isPeak, trainsPerHour, directionId) {
        try {
            const response = await fetch(`${API_BASE}/demand/predict`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    hour,
                    is_weekend: isWeekend,
                    is_peak_hour: isPeak ? 1 : 0,
                    trains_per_hour: trainsPerHour,
                    direction_id: directionId
                })
            });
            const data = await response.json();
            return {
                estimated_demand: data.predicted_demand || 5000,
                weather_factor: 1.0
            };
        } catch (e) {
            console.error("Demand API Error:", e);
            return { estimated_demand: 5000, weather_factor: 1.0 };
        }
    }

    // ========== TRAIN INDUCTION API ==========
    async function fetchTrainRecommendation(predictedDemand, isPeak) {
        try {
            const response = await fetch(`${API_BASE}/induction/recommend`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    predicted_demand: predictedDemand,
                    is_peak_hour: isPeak ? 1 : 0
                })
            });
            return await response.json();
        } catch (e) {
            console.error("Induction API Error:", e);
            return { recommended_trains: 5, confidence: 78, policy: "error" };
        }
    }

    // ========== INDUCTION SYSTEM STATUS ==========
    async function getInductionSystemStatus() {
        try {
            const response = await fetch(`${API_BASE}/induction/status`);
            return await response.json();
        } catch (e) {
            console.error("Status API Error:", e);
            return { status: "unavailable", rl_model_loaded: false };
        }
    }

    // ========== SURGE DETECTION ==========
    function detectSurge(predictedDemand, threshold = 7000) {
        if (predictedDemand >= threshold) {
            return { surge: true, severity: "High" };
        } else if (predictedDemand >= threshold * 0.8) {
            return { surge: true, severity: "Medium" };
        } else {
            return { surge: false, severity: "Low" };
        }
    }

    // ========== WEATHER-BASED DEMAND MULTIPLIER ==========
    function weatherDemandMultiplier(weather) {
        let factor = 1.0;
        if (weather.rain_mm > 5) factor += 0.2;
        if (weather.condition.includes("Heavy")) factor += 0.1;
        if (weather.temp > 34) factor -= 0.05;
        return factor;
    }

    // ========== DEMAND LEVEL DISCRETIZATION ==========
    function getDemandLevel(demand) {
        if (demand < 3000) return 0;
        if (demand < 6000) return 1;
        return 2;
    }

    // ========== GENERATE EXPLANATION ==========
    function generateExplanation(demand, trains, weather, isPeak) {
        return `Based on predicted passenger demand of ${demand}, deploying ${trains} trains is recommended. Weather: ${weather.condition}, ${weather.rain_mm}mm rain, ${weather.temp}¬∞C. Peak hour: ${isPeak ? 'Yes' : 'No'}.`;
    }
    </script>

    <script>
        
        /* ---------------- TAB SWITCH ---------------- */
        function switchTab(index) {
            const tabs = document.querySelectorAll(".nav-tab");
            const contents = document.querySelectorAll(".tab-content");
        
            tabs.forEach((t, i) => {
                t.classList.toggle("active", i === index);
                contents[i].classList.toggle("active", i === index);
            });
        }           
        
        /* ---------------- METRO LINE STATUS ---------------- */
        function updateMetroLineStatus() {
            const stationList = document.getElementById("stationList");
            // Hardcoded station names
            const STATIONS = [
                "Aluva", "Pulinchodu", "Companypady", "Ambattukavu",
                "Muttom", "Kalamassery", "CUSAT", "Edappally",
                "Kaloor", "MG Road", "Maharaja‚Äôs", "Ernakulam South"
            ];
        
            // Get hour from slider for icon logic
            const hour = parseInt(document.getElementById("hour").value);
        
            // Generate random congestion for demo
            stationList.innerHTML = STATIONS.map((s, i) => {
                const congestion = Math.random(); // Replace with real logic if needed
                const color = congestion < 0.5 ? "üü¢" : (congestion < 0.8 ? "üü°" : "üî¥");
                const icon = i === hour % STATIONS.length ? "üöÜ" : "‚ûñ";
                return `
                    <div class="station-item">
                        <span>${color} <strong>${s}</strong> ${icon}</span>
                    </div>
                `;
            }).join('');
        }

        // Call Metro Line Status on page load
        window.addEventListener('DOMContentLoaded', () => {
            updateMetroLineStatus();

            // Initialize display values for sliders
            updateHourDisplay(document.getElementById("hour").value);
            updateTrainsPerHourDisplay(document.getElementById("trainsPerHour").value);
            updateTrainsDisplay(document.getElementById("availableTrains").value);
            updateDemandDisplay(document.getElementById("demandIncrease").value);
            updateUnavailableDisplay(document.getElementById("unavailableTrains").value);
        });
        
        /* ---------------- SLIDER HELPERS ---------------- */
        function updateHourDisplay(val) {
            document.getElementById("hourDisplay").innerText = `${val}:00`;
        }

        // Fix: Add missing function for Current Trains / Hour slider
        function updateTrainsPerHourDisplay(val) {
            document.getElementById("trainsDisplay").innerText = val;
        }
        
        function updateTrainsDisplay(val) {
            document.getElementById("availableTrainsDisplay").innerText = val;
        }
        
        function updateDemandDisplay(val) {
            document.getElementById("demandIncreaseDisplay").innerText = `${val}%`;
        }
        
        function updateUnavailableDisplay(val) {
            document.getElementById("unavailableDisplay").innerText = val;
        }
        
        /* ---------------- MAIN AI FLOW (WITH BACKEND INTEGRATION) ---------------- */
        async function runAI() {
            const hour = parseInt(document.getElementById("hour").value);
            const dayType = document.getElementById("dayType").value;
            const trainsPerHour = parseInt(document.getElementById("trainsPerHour").value);
            const direction = parseInt(document.getElementById("direction").value);
            const isWeekend = dayType === "weekend" ? 1 : 0;
            const isPeak = (hour >= 8 && hour <= 10) || (hour >= 17 && hour <= 20) ? 1 : 0;

            // Show loading state
            document.getElementById("aiRecommendation").innerHTML = `<div class="info-box">‚è≥ Processing AI decision...</div>`;

            try {
                // 1Ô∏è‚É£ Fetch weather
                const weather = await getWeatherData();

                // 2Ô∏è‚É£ Call Demand Forecasting API
                const demandResult = await fetchDemandForecast(hour, isWeekend, isPeak, trainsPerHour, direction);
                const predictedDemand = demandResult.estimated_demand || 5000;

                // 3Ô∏è‚É£ Call Train Induction API (RL-based)
                const inductionResult = await fetchTrainRecommendation(predictedDemand, isPeak);
                const recommendedTrains = inductionResult.recommended_trains;
                const confidence = inductionResult.confidence;
                const policy = inductionResult.policy;

                // 4Ô∏è‚É£ Detect surges
                const surgeStatus = detectSurge(predictedDemand);

                // 5Ô∏è‚É£ Calculate multiplier
                const demandMultiplier = weatherDemandMultiplier(weather);

                // 6Ô∏è‚É£ Update AI Recommendation card with all backend data
                let surgeAlert = '';
                if (surgeStatus.surge) {
                    surgeAlert = `<div class="warning-box">‚ö†Ô∏è <strong>SURGE DETECTED:</strong> ${surgeStatus.severity} intensity. Extra trains may be needed.</div>`;
                }

                document.getElementById("aiRecommendation").innerHTML = `
                    ${surgeAlert}
                    <div class="success-box">
                        <strong>‚úì AI Decision Generated</strong><br>
                        <strong>Recommended Trains/Hour:</strong> ${recommendedTrains}<br>
                        <strong>Confidence Level:</strong> ${confidence}%<br>
                        <strong>Policy Used:</strong> ${policy === 'reinforcement-learning' ? 'ü§ñ Reinforcement Learning' : 'üìã Rule-Based'}<br><br>
                        
                        <strong>Predicted Passenger Demand:</strong> ${Math.round(predictedDemand)} passengers<br>
                        <strong>Direction:</strong> ${direction === 0 ? "Aluva ‚Üí Ernakulam" : "Ernakulam ‚Üí Aluva"}<br><br>
                        
                        <strong>Weather Impact:</strong><br>
                        ‚Ä¢ Condition: ${weather.condition}<br>
                        ‚Ä¢ Rainfall: ${weather.rain_mm}mm<br>
                        ‚Ä¢ Temperature: ${weather.temp}¬∞C<br>
                        ‚Ä¢ Demand Multiplier: ${demandMultiplier.toFixed(2)}√ó<br><br>
                        
                        <strong>Headway (minutes):</strong> ${Math.round(60 / recommendedTrains)}<br>
                        <strong>Peak Hour:</strong> ${isPeak ? 'Yes' : 'No'}
                    </div>
                `;

                updateKPIs(predictedDemand, recommendedTrains);
                updateChart(predictedDemand, hour);
                updateMetroLineStatus();

            } catch (error) {
                console.error("AI Flow Error:", error);
                document.getElementById("aiRecommendation").innerHTML = `
                    <div class="error-box">
                        <strong>‚ùå Error:</strong> Backend service unavailable. Please ensure the FastAPI server is running at ${API_BASE}
                    </div>
                `;
            }
        }
        
        /* ---------------- KPI UPDATE (WITH BACKEND DATA) ---------------- */
        function updateKPIs(demand, trains) {
            const metrics = document.querySelectorAll(".metric-value");
            
            // KPI calculations based on Streamlit logic
            const waitingTime = Math.max(2, 12 - trains);
            const loadPercentage = Math.min(100, Math.round((demand / (trains * TRAIN_CAPACITY)) * 100));
            const energyConsumption = Math.max(60, 100 - trains * 4);
            const comfortLevel = Math.max(50, 100 - loadPercentage);
            
            metrics[0].innerText = `${waitingTime} min`;
            metrics[1].innerText = `${loadPercentage}%`;
            metrics[2].innerText = `${energyConsumption}%`;
            metrics[3].innerText = `${comfortLevel}%`;
        }
        
        /* ---------------- CHART (WITH TIME SERIES) ---------------- */
        let demandChart;
        
        function updateChart(value, currentHour) {
            const ctx = document.getElementById("demandChart").getContext("2d");
        
            if (demandChart) demandChart.destroy();
        
            // Generate next 5 hours of projected demand
            const labels = [];
            const data = [];
            for (let i = 0; i < 5; i++) {
                const hour = (currentHour + i) % 24;
                labels.push(`${hour}:00`);
                // Simulate demand based on hour (peak hours 8-10, 17-20)
                const isPeakHour = (hour >= 8 && hour <= 10) || (hour >= 17 && hour <= 20);
                const variance = isPeakHour ? 1.2 : (hour >= 6 && hour <= 22 ? 1.0 : 0.3);
                data.push(value * variance * (0.9 + i * 0.05));
            }
        
            demandChart = new Chart(ctx, {
                type: "line",
                data: {
                    labels: labels,
                    datasets: [{
                        label: "Predicted Passenger Demand",
                        data: data,
                        borderColor: "#667eea",
                        backgroundColor: "rgba(102, 126, 234, 0.1)",
                        borderWidth: 2,
                        fill: true,
                        tension: 0.3
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { 
                        legend: { 
                            display: true,
                            labels: { color: "#495057", font: { size: 12 } }
                        } 
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: { color: "#6c757d" },
                            grid: { color: "rgba(0,0,0,0.05)" }
                        },
                        x: {
                            ticks: { color: "#6c757d" },
                            grid: { color: "rgba(0,0,0,0.05)" }
                        }
                    }
                }
            });
        }
        
        /* Fetch all demand data once (prevents duplicate API calls) */
        async function fetchAllDemandData(timeStart, timeEnd, dayType) {
            const isWeekend = dayType === "weekend" ? 1 : 0;
            const predictedByHour = {};

            for (let hour = timeStart; hour <= timeEnd; hour++) {
                const isPeak = (hour >= 8 && hour <= 10) || (hour >= 17 && hour <= 20) ? 1 : 0;
                const result = await fetchDemandForecast(hour, isWeekend, isPeak, 5, 0);
                predictedByHour[hour] = Math.round(result.estimated_demand || 5000);
            }

            return predictedByHour;
        }

        /* ---------------- DEMAND ANALYTICS (WITH API) - OPTIMIZED TO REDUCE API CALLS ---------------- */
        async function runDemandAnalytics() {
            const dayType = document.getElementById("analyticsDayType").value;
            const timeStart = parseInt(document.getElementById("timeStart").value);
            const timeEnd = parseInt(document.getElementById("timeEnd").value);
            const isWeekend = dayType === "weekend" ? 1 : 0;

            document.getElementById("heatmapContainer").innerHTML = `<div class="info-box">‚è≥ Loading demand analytics from backend API (fetching data once)...</div>`;

            try {
                const stations = [
                    "Aluva", "Pulinchodu", "Companypady", "Ambattukavu",
                    "Muttom", "Kalamassery", "CUSAT", "Edappally",
                    "Kaloor", "MG Road", "Maharaja's", "Ernakulam South"
                ];

                // ‚úÖ FETCH DATA ONCE - reduces ~200 API calls to just ~17 calls
                const predictedByHour = await fetchAllDemandData(timeStart, timeEnd, dayType);

                // Build heatmap data using cached predictions
                const heatmapData = {};
                const hourLabels = [];

                for (let hour = timeStart; hour <= timeEnd; hour++) {
                    hourLabels.push(hour);
                }

                stations.forEach((station, stationIdx) => {
                    heatmapData[station] = [];
                    
                    for (let hour of hourLabels) {
                        let stationDemand = predictedByHour[hour];
                        
                        // Add variation based on station proximity to major hubs
                        if (stationIdx === 9 || stationIdx === 8) { // Central stations
                            stationDemand *= 1.3;
                        }
                        if (stationIdx === 0 || stationIdx === 11) { // Terminal stations
                            stationDemand *= 0.7;
                        }
                        
                        heatmapData[station].push({
                            hour: hour,
                            demand: Math.round(stationDemand)
                        });
                    }
                });

                // Generate heatmap HTML
                let heatmapHTML = `
                    <div class="heatmap">
                        <div class="heatmap-row">
                            <div class="heatmap-cell heatmap-header">Station / Hour</div>
                            ${hourLabels.map(h => `<div class="heatmap-cell heatmap-header">${h}:00</div>`).join('')}
                        </div>
                `;

                stations.forEach(station => {
                    heatmapHTML += `<div class="heatmap-row">
                        <div class="heatmap-cell heatmap-label">${station}</div>`;
                    
                    heatmapData[station].forEach(d => {
                        const intensity = Math.min(100, (d.demand / 7000) * 100);
                        const color = getHeatmapColor(intensity);
                        heatmapHTML += `<div class="heatmap-cell" style="background-color: ${color};"></div>`;
                    });
                    
                    heatmapHTML += `</div>`;
                });

                heatmapHTML += `</div>`;
                
                // Add legend
                heatmapHTML += `
                    <div style="margin-top: 15px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                        <h4>üìä Demand Intensity Legend</h4>
                        <div style="display: flex; gap: 8px; flex-wrap: wrap; align-items: center;">
                            <div style="display: flex; align-items: center; gap: 5px;">
                                <div style="width: 20px; height: 20px; background: #d4edda; border-radius: 3px; border: 1px solid #ddd;"></div>
                                <span style="font-size: 0.85em;">Very Low</span>
                            </div>
                            <div style="display: flex; align-items: center; gap: 5px;">
                                <div style="width: 20px; height: 20px; background: #28a745; border-radius: 3px;"></div>
                                <span style="font-size: 0.85em;">Low</span>
                            </div>
                            <div style="display: flex; align-items: center; gap: 5px;">
                                <div style="width: 20px; height: 20px; background: #ffc107; border-radius: 3px;"></div>
                                <span style="font-size: 0.85em;">Medium</span>
                            </div>
                            <div style="display: flex; align-items: center; gap: 5px;">
                                <div style="width: 20px; height: 20px; background: #fd7e14; border-radius: 3px;"></div>
                                <span style="font-size: 0.85em;">High</span>
                            </div>
                            <div style="display: flex; align-items: center; gap: 5px;">
                                <div style="width: 20px; height: 20px; background: #e74c3c; border-radius: 3px;"></div>
                                <span style="font-size: 0.85em;">Very High</span>
                            </div>
                            <div style="display: flex; align-items: center; gap: 5px;">
                                <div style="width: 20px; height: 20px; background: #8B0000; border-radius: 3px;"></div>
                                <span style="font-size: 0.85em;">Peak</span>
                            </div>
                        </div>
                    </div>
                `;
                
                document.getElementById("heatmapContainer").innerHTML = heatmapHTML;

                // ‚úÖ Generate chart using cached data (NO additional API calls)
                await generateHistoricalVsPredictedChart(timeStart, timeEnd, dayType, predictedByHour);

            } catch (error) {
                console.error("Analytics Error:", error);
                document.getElementById("heatmapContainer").innerHTML = `
                    <div class="error-box">
                        <strong>‚ùå Error:</strong> Failed to load analytics. Backend API may be unavailable at ${API_BASE}/demand/predict
                    </div>
                `;
            }
        }

        function getHeatmapColor(intensity) {
            // Dynamic color gradient: Green ‚Üí Yellow ‚Üí Orange ‚Üí Red ‚Üí Dark Red/Maroon
            // Based on intensity percentage (0-100%)
            
            if (intensity < 15) return "#d4edda";      // Very light green
            if (intensity < 25) return "#28a745";      // Light green
            if (intensity < 35) return "#20c997";      // Green
            if (intensity < 45) return "#ffeaa7";      // Light yellow
            if (intensity < 55) return "#ffc107";      // Yellow
            if (intensity < 65) return "#fd7e14";      // Orange
            if (intensity < 75) return "#f97316";      // Dark orange
            if (intensity < 85) return "#e74c3c";      // Red
            if (intensity < 92) return "#c0392b";      // Dark red
            return "#8B0000";                          // Maroon/Dark red for peak demand
        }

        /* Generate Historical Demand (simulated pattern-based) */
        function generateHistoricalDemand(hour, dayType) {
            // Base pattern: higher during peak hours, lower at night
            let baseDemand = 2000; // Base late night demand
            
            if (hour >= 6 && hour < 8) baseDemand = 3500; // Morning commute start
            if (hour >= 8 && hour < 10) baseDemand = 6500; // Morning peak
            if (hour >= 10 && hour < 12) baseDemand = 4500; // Mid-morning
            if (hour >= 12 && hour < 14) baseDemand = 4000; // Lunch hours
            if (hour >= 14 && hour < 16) baseDemand = 3500; // Afternoon
            if (hour >= 16 && hour < 17) baseDemand = 4500; // Afternoon commute start
            if (hour >= 17 && hour < 20) baseDemand = 7000; // Evening peak
            if (hour >= 20 && hour < 22) baseDemand = 5000; // Late evening
            if (hour >= 22) baseDemand = 2500; // Night
            
            // Weekend variation (lower demand)
            if (dayType === "weekend") {
                baseDemand *= 0.75;
            }
            
            // Add random variation (¬±10%)
            const variation = baseDemand * (0.9 + Math.random() * 0.2);
            return Math.round(variation);
        }

        let historicalVsPredictedChart;

        /* Generate Historical vs AI-Predicted Demand Chart (uses cached data) */
        async function generateHistoricalVsPredictedChart(timeStart, timeEnd, dayType, cachedPredictedData) {
            const ctx = document.getElementById("historicalVsPredictedChart");
            
            if (!ctx) return; // Chart element not present
            
            if (historicalVsPredictedChart) {
                historicalVsPredictedChart.destroy();
            }

            try {
                const labels = [];
                const historicalData = [];
                const predictedData = [];

                // Build chart data using cached predictions (NO additional API calls)
                for (let hour = timeStart; hour <= timeEnd; hour++) {
                    labels.push(`${hour}:00`);
                    
                    // Historical demand (simulated based on patterns)
                    historicalData.push(generateHistoricalDemand(hour, dayType));
                    
                    // Use cached predicted demand
                    predictedData.push(cachedPredictedData[hour]);
                }

                const chartCtx = ctx.getContext("2d");
                historicalVsPredictedChart = new Chart(chartCtx, {
                    type: "line",
                    data: {
                        labels: labels,
                        datasets: [
                            {
                                label: "üìä Historical Demand (Past Week Average)",
                                data: historicalData,
                                borderColor: "#6c757d",
                                backgroundColor: "rgba(108, 117, 125, 0.1)",
                                borderWidth: 2,
                                borderDash: [5, 5], // Dashed line for historical
                                fill: false,
                                tension: 0.3,
                                pointRadius: 4,
                                pointBackgroundColor: "#6c757d",
                                pointBorderColor: "white",
                                pointBorderWidth: 2
                            },
                            {
                                label: "ü§ñ AI-Predicted Demand (ML Model)",
                                data: predictedData,
                                borderColor: "#667eea",
                                backgroundColor: "rgba(102, 126, 234, 0.1)",
                                borderWidth: 3,
                                fill: false,
                                tension: 0.3,
                                pointRadius: 5,
                                pointBackgroundColor: "#667eea",
                                pointBorderColor: "white",
                                pointBorderWidth: 2
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false
                        },
                        plugins: {
                            legend: {
                                display: true,
                                labels: {
                                    color: "#495057",
                                    font: { size: 13, weight: "bold" },
                                    padding: 15,
                                    usePointStyle: true
                                }
                            },
                            tooltip: {
                                mode: 'index',
                                intersect: false,
                                backgroundColor: "rgba(0,0,0,0.8)",
                                padding: 12,
                                titleFont: { size: 13, weight: "bold" },
                                bodyFont: { size: 12 },
                                callbacks: {
                                    afterLabel: function(context) {
                                        if (context.datasetIndex === 0) {
                                            return "Historical average";
                                        } else {
                                            return "ML prediction";
                                        }
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    color: "#6c757d",
                                    font: { size: 11 }
                                },
                                grid: { color: "rgba(0,0,0,0.05)" },
                                title: {
                                    display: true,
                                    text: "Passenger Demand",
                                    color: "#495057",
                                    font: { size: 12, weight: "bold" }
                                }
                            },
                            x: {
                                ticks: {
                                    color: "#6c757d",
                                    font: { size: 11 }
                                },
                                grid: { color: "rgba(0,0,0,0.05)" },
                                title: {
                                    display: true,
                                    text: "Time of Day",
                                    color: "#495057",
                                    font: { size: 12, weight: "bold" }
                                }
                            }
                        }
                    }
                });
            } catch (error) {
                console.error("Chart Generation Error:", error);
            }
        }
        
        /* ---------------- TRAIN PLANNING WITH AI (TAB 3) ---------------- */
        async function generatePlan() {
            const availableTrains = parseInt(document.getElementById("availableTrains").value);
            const isPeakMode = document.getElementById("peakMode").checked;

            document.getElementById("planningOutput").innerHTML = `<div class="info-box">‚è≥ Generating AI plan...</div>`;

            try {
                // Get system status
                const systemStatus = await getInductionSystemStatus();
                const rlModelLoaded = systemStatus.rl_model_loaded;
                
                const planResults = [];
                let allRecommendations = [];

                // Generate plan for different hours
                for (let hour = 6; hour <= 22; hour++) {
                    const isPeak = (hour >= 8 && hour <= 10) || (hour >= 17 && hour <= 20);
                    
                    if (isPeakMode && !isPeak) continue; // Skip non-peak hours if peak mode
                    
                    // Get demand forecast
                    const demandResult = await fetchDemandForecast(hour, 0, isPeak ? 1 : 0, 5, 0);
                    const predictedDemand = demandResult.estimated_demand || 5000;

                    // Get train recommendation from RL model
                    const inductionResult = await fetchTrainRecommendation(predictedDemand, isPeak);
                    const recommendedTrains = Math.min(inductionResult.recommended_trains, availableTrains);

                    planResults.push({
                        hour: hour,
                        demand: predictedDemand,
                        trains: recommendedTrains,
                        headway: inductionResult.headway || Math.round(60 / recommendedTrains),
                        waitingTime: inductionResult.expected_waiting_time || (inductionResult.headway ? inductionResult.headway / 2 : 0),
                        crowdingRisk: inductionResult.overcrowding_risk || "Unknown",
                        confidence: inductionResult.confidence || 78,
                        policy: inductionResult.policy || "unknown",
                        explanation: inductionResult.explanation || ""
                    });

                    allRecommendations.push(inductionResult);
                }

                // Calculate peak hour recommendation (average of peak hours)
                const peakResults = planResults.filter(r => (r.hour >= 8 && r.hour <= 10) || (r.hour >= 17 && r.hour <= 20));
                
                let avgTrains, avgDemand, avgHeadway, avgWaitingTime, avgCrowdingRisk, avgConfidence;
                
                if (peakResults.length > 0) {
                    avgTrains = Math.round(peakResults.reduce((sum, r) => sum + r.trains, 0) / peakResults.length);
                    avgDemand = Math.round(peakResults.reduce((sum, r) => sum + r.demand, 0) / peakResults.length);
                    avgHeadway = Math.round(peakResults.reduce((sum, r) => sum + r.headway, 0) / peakResults.length);
                    avgWaitingTime = (peakResults.reduce((sum, r) => sum + r.waitingTime, 0) / peakResults.length).toFixed(1);
                    avgConfidence = Math.round(peakResults.reduce((sum, r) => sum + r.confidence, 0) / peakResults.length);
                    
                    // Determine overall crowding risk (take worst case)
                    const riskLevels = { "Low": 1, "Medium": 2, "High": 3 };
                    avgCrowdingRisk = Object.keys(riskLevels).find(k => 
                        riskLevels[k] === Math.ceil(peakResults.reduce((sum, r) => sum + (riskLevels[r.crowdingRisk] || 1), 0) / peakResults.length)
                    ) || "Medium";
                } else {
                    avgTrains = planResults[0]?.trains || 5;
                    avgDemand = planResults[0]?.demand || 5000;
                    avgHeadway = planResults[0]?.headway || 12;
                    avgWaitingTime = planResults[0]?.waitingTime?.toFixed(1) || 6.0;
                    avgCrowdingRisk = planResults[0]?.crowdingRisk || "Unknown";
                    avgConfidence = planResults[0]?.confidence || 78;
                }
                
                // Determine color based on crowding risk
                let crowdingColor = "#28a745";
                if (avgCrowdingRisk === "Medium") crowdingColor = "#ffc107";
                if (avgCrowdingRisk === "High") crowdingColor = "#dc3545";

                // Generate policy indicator
                const policyLabel = allRecommendations[0]?.policy === "reinforcement-learning" 
                    ? "Reinforcement Learning ü§ñ" 
                    : "Rule-Based Fallback üìã";

                // Generate HTML output with metrics cards
                let planHTML = `
                    <div style="margin-bottom: 30px;">
                        <h3 style="color: #495057; margin-bottom: 20px;">üìä AI Output Preview</h3>
                        <h4 style="color: #667eea; margin-bottom: 20px;">ü§ñ AI Deployment Recommendation</h4>
                        
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px;">
                            <!-- Trains to Deploy -->
                            <div class="metric" style="flex-direction: column; align-items: flex-start; padding: 20px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #667eea;">
                                <span class="metric-label" style="font-size: 0.9em; margin-bottom: 10px;">üöÜ Trains to Deploy</span>
                                <span class="metric-value" style="font-size: 2.5em; color: #667eea;">${avgTrains}</span>
                                <span style="font-size: 0.85em; color: #6c757d; margin-top: 5px;">of ${availableTrains} available</span>
                            </div>
                            
                            <!-- Headway -->
                            <div class="metric" style="flex-direction: column; align-items: flex-start; padding: 20px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #17a2b8;">
                                <span class="metric-label" style="font-size: 0.9em; margin-bottom: 10px;">‚è± Headway (min)</span>
                                <span class="metric-value" style="font-size: 2.5em; color: #17a2b8;">${avgHeadway}</span>
                                <span style="font-size: 0.85em; color: #6c757d; margin-top: 5px;">Time between trains</span>
                            </div>
                            
                            <!-- Waiting Time -->
                            <div class="metric" style="flex-direction: column; align-items: flex-start; padding: 20px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #28a745;">
                                <span class="metric-label" style="font-size: 0.9em; margin-bottom: 10px;">‚åõ Expected Waiting Time</span>
                                <span class="metric-value" style="font-size: 2.5em; color: #28a745;">${avgWaitingTime}</span>
                                <span style="font-size: 0.85em; color: #6c757d; margin-top: 5px;">Average wait (min)</span>
                            </div>
                            
                            <!-- Overcrowding Risk -->
                            <div class="metric" style="flex-direction: column; align-items: flex-start; padding: 20px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid ${crowdingColor};">
                                <span class="metric-label" style="font-size: 0.9em; margin-bottom: 10px;">üü° Overcrowding Risk</span>
                                <span class="metric-value" style="font-size: 2em; color: ${crowdingColor};">${avgCrowdingRisk}</span>
                                <span style="font-size: 0.85em; color: #6c757d; margin-top: 5px;">Peak demand: ${avgDemand}</span>
                            </div>
                        </div>
                        
                        <!-- AI Insight -->
                        <div style="background: #e7f3ff; border-left: 4px solid #667eea; padding: 20px; border-radius: 8px; margin-top: 20px;">
                            <h4 style="color: #667eea; margin-bottom: 10px;">üß† AI Insight:</h4>
                            <p style="color: #495057; line-height: 1.6;">
                                Using <strong>${policyLabel}</strong>, the AI agent evaluated multiple deployment actions and selected <strong>${avgTrains} trains</strong> 
                                to balance passenger satisfaction (${avgWaitingTime} min avg wait), operational efficiency (${avgHeadway}-min headway), 
                                and congestion risk (<strong>${avgCrowdingRisk}</strong>) under peak-hour conditions. 
                                <br/><br/>
                                <strong>Fleet Utilization:</strong> ${((avgTrains / availableTrains) * 100).toFixed(1)}% of ${availableTrains} available trains. 
                                <strong>Model Confidence:</strong> ${avgConfidence}%.
                                ${!rlModelLoaded ? '<br/><br/>‚ö†Ô∏è <strong>Note:</strong> RL model not loaded. Using rule-based fallback.' : ''}
                            </p>
                        </div>
                        
                        <details style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; cursor: pointer;">
                            <summary style="font-weight: 600; color: #667eea; margin-bottom: 10px;">üìã Hourly Breakdown (Click to expand)</summary>
                            <div style="margin-top: 15px; overflow-x: auto;">
                                <table style="width: 100%; border-collapse: collapse;">
                                    <thead>
                                        <tr style="background: #667eea; color: white;">
                                            <th style="padding: 10px; text-align: left;">Hour</th>
                                            <th style="padding: 10px; text-align: center;">Peak</th>
                                            <th style="padding: 10px; text-align: center;">Demand</th>
                                            <th style="padding: 10px; text-align: center;">Trains</th>
                                            <th style="padding: 10px; text-align: center;">Headway</th>
                                            <th style="padding: 10px; text-align: center;">Wait (min)</th>
                                            <th style="padding: 10px; text-align: center;">Risk</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                `;

                planResults.forEach(r => {
                    const riskColor = r.crowdingRisk === "Low" ? "#28a745" : (r.crowdingRisk === "Medium" ? "#ffc107" : "#dc3545");
                    const isPeakHour = (r.hour >= 8 && r.hour <= 10) || (r.hour >= 17 && r.hour <= 20);
                    planHTML += `
                        <tr style="border-bottom: 1px solid #dee2e6; ${isPeakHour ? 'background: #f0f0ff;' : ''}">
                            <td style="padding: 10px; font-weight: bold;">${r.hour}:00</td>
                            <td style="padding: 10px; text-align: center;">${isPeakHour ? 'üìç' : '‚Äî'}</td>
                            <td style="padding: 10px; text-align: center;">${Math.round(r.demand)}</td>
                            <td style="padding: 10px; text-align: center; font-weight: bold; color: #667eea;">${r.trains}</td>
                            <td style="padding: 10px; text-align: center;">${r.headway}</td>
                            <td style="padding: 10px; text-align: center;">${r.waitingTime.toFixed(1)}</td>
                            <td style="padding: 10px; text-align: center; color: ${riskColor}; font-weight: bold;">${r.crowdingRisk}</td>
                        </tr>
                    `;
                });

                planHTML += `
                                    </tbody>
                                </table>
                            </div>
                        </details>
                    </div>
                `;

                document.getElementById("planningOutput").innerHTML = planHTML;


            } catch (error) {
                console.error("Planning Error:", error);
                document.getElementById("planningOutput").innerHTML = `
                    <div class="error-box">Error generating plan. Backend unavailable.</div>
                `;
            }
        }
        
        /* ---------------- SCENARIO SIMULATOR (TAB 4) ---------------- */
        async function runSimulation() {
            const demandIncrease = parseInt(document.getElementById("demandIncrease").value);
            const unavailableTrains = parseInt(document.getElementById("unavailableTrains").value);
            const hasRain = document.getElementById("rain").checked;
            const hasFestival = document.getElementById("festival").checked;

            document.getElementById("simulationResults").innerHTML = `<div class="info-box">‚è≥ Running scenario simulation...</div>`;

            try {
                // Base scenario at peak hour
                const baseResult = await fetchDemandForecast(9, 0, 1, 5, 0);
                const baseDemand = baseResult.estimated_demand || 5000;

                // Apply multipliers
                let scenarioDemand = baseDemand * (1 + demandIncrease / 100);
                if (hasRain) scenarioDemand *= 1.2;
                if (hasFestival) scenarioDemand *= 1.35;

                // Get train recommendation
                const inductionResult = await fetchTrainRecommendation(Math.round(scenarioDemand), 1);
                const recommendedTrains = inductionResult.recommended_trains;
                const availableTrains = 10 - unavailableTrains;
                const canMeetDemand = recommendedTrains <= availableTrains;

                // Detect surge
                const surgeStatus = detectSurge(Math.round(scenarioDemand));

                // Calculate metrics
                const headway = Math.round(60 / recommendedTrains);
                const waitingTime = headway / 2;
                const crowdingLevel = Math.min(100, (scenarioDemand / 8000) * 100);

                let resultHTML = `
                    <div class="${canMeetDemand ? 'success' : 'error'}-box">
                        <strong>${canMeetDemand ? '‚úì Scenario Manageable' : '‚ùå Capacity Exceeded'}</strong><br>
                        ${canMeetDemand 
                            ? `Available trains are sufficient to handle the scenario.`
                            : `Warning: Recommended ${recommendedTrains} trains but only ${availableTrains} available.`
                        }
                    </div>

                    <div style="margin-top: 20px;">
                        <h4>üìä Simulation Results</h4>
                        <div class="metric" style="margin-bottom: 10px;">
                            <span class="metric-label">Base Passenger Demand</span>
                            <span class="metric-value">${Math.round(baseDemand)}</span>
                        </div>
                        <div class="metric" style="margin-bottom: 10px;">
                            <span class="metric-label">Scenario Demand (with multipliers)</span>
                            <span class="metric-value">${Math.round(scenarioDemand)}</span>
                        </div>
                        <div class="metric" style="margin-bottom: 10px;">
                            <span class="metric-label">Demand Increase Applied</span>
                            <span class="metric-value">${demandIncrease}%</span>
                        </div>
                        
                        <h4 style="margin-top: 20px;">üöÜ Train Configuration</h4>
                        <div class="metric" style="margin-bottom: 10px;">
                            <span class="metric-label">Available Trains</span>
                            <span class="metric-value">${availableTrains}</span>
                        </div>
                        <div class="metric" style="margin-bottom: 10px;">
                            <span class="metric-label">Recommended Trains</span>
                            <span class="metric-value">${recommendedTrains}</span>
                        </div>
                        <div class="metric" style="margin-bottom: 10px;">
                            <span class="metric-label">Headway (minutes)</span>
                            <span class="metric-value">${headway}</span>
                        </div>
                        
                        <h4 style="margin-top: 20px;">‚ö†Ô∏è Impact Assessment</h4>
                        <div class="metric" style="margin-bottom: 10px;">
                            <span class="metric-label">Average Waiting Time</span>
                            <span class="metric-value">${waitingTime.toFixed(1)} min</span>
                        </div>
                        <div class="metric" style="margin-bottom: 10px;">
                            <span class="metric-label">Crowding Level</span>
                            <span class="metric-value">${crowdingLevel.toFixed(0)}%</span>
                        </div>
                        <div class="metric" style="margin-bottom: 10px;">
                            <span class="metric-label">Surge Status</span>
                            <span class="metric-value">${surgeStatus.surge ? `‚ö†Ô∏è ${surgeStatus.severity}` : '‚úì Normal'}</span>
                        </div>

                        <h4 style="margin-top: 20px;">üå¶Ô∏è Applied Factors</h4>
                        ${hasRain ? '<div style="padding: 8px; background: #e7f3ff; border-radius: 5px; margin-bottom: 8px;">üåßÔ∏è Rain: +20% demand</div>' : ''}
                        ${hasFestival ? '<div style="padding: 8px; background: #fff3cd; border-radius: 5px; margin-bottom: 8px;">üéâ Festival: +35% demand</div>' : ''}
                        ${!hasRain && !hasFestival ? '<div style="padding: 8px; background: #f8f9fa; border-radius: 5px;">No special factors applied</div>' : ''}
                    </div>
                `;

                document.getElementById("simulationResults").innerHTML = resultHTML;

            } catch (error) {
                console.error("Simulation Error:", error);
                document.getElementById("simulationResults").innerHTML = `
                    <div class="error-box">Error running simulation. Backend unavailable.</div>
                `;
            }
        }
        </script>
        

    
</body>
</html>
